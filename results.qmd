---
title: "Results"
format: html
---

# Results

## Executive Summary

This section presents the key findings from our sector-based financial analysis of Technology, Healthcare, and Banking stocks listed on NASDAQ over the past five years. Our analysis reveals distinct performance patterns, risk profiles, and sensitivities to economic indicators across the sectors. Notably, the Technology sector demonstrated robust growth and resilience, while the Banking sector exhibited higher volatility influenced by interest rate fluctuations.

## 1. Stock Performances on each sector

### 1.1 Closing Price

```{r fig.height=12, fig.width=15}
# Load necessary libraries
library(ggplot2)
library(dplyr)
library(readr)
library(tidyr)
library(lubridate)
library(zoo)  # for rollmean

# List the CSV files for each sector
banking_files <- list.files(path = "./Datasets/Banking/", pattern = "*.csv", full.names = TRUE)
tech_files <- list.files(path = "./Datasets/TECH/", pattern = "*.csv", full.names = TRUE)
health_files <- list.files(path = "./Datasets/Healthcare and Pharma/", pattern = "*.csv", full.names = TRUE)

# Define the function to read and process data for a single file and sector
read_sector_data <- function(file_path, sector) {
  data <- read_csv(file_path, show_col_types = FALSE)  
  
  colnames(data) <- tolower(gsub("\\s+", "_", colnames(data)))  
  
  required_columns <- c("date", "close", "open", "high", "low")
  missing_columns <- setdiff(required_columns, colnames(data))
  if (length(missing_columns) > 0) {
    stop(paste("Missing required columns in file:", file_path, 
               "-> Missing columns:", paste(missing_columns, collapse = ", ")))
  }
  
  data <- data |>
    mutate(
      date = mdy(date),  
      close = as.numeric(gsub("\\$", "", close)),  
      open = as.numeric(gsub("\\$", "", open)),
      high = as.numeric(gsub("\\$", "", high)),
      low = as.numeric(gsub("\\$", "", low)),
      volume = as.numeric(gsub(",", "", volume))  
    ) |>
    mutate(
      Sector = sector,
      Source = tools::file_path_sans_ext(basename(file_path))
    )
  
  return(data)
}

# Read and combine data for each sector
banking_data <- bind_rows(lapply(banking_files, read_sector_data, sector = "Banking"))
tech_data <- bind_rows(lapply(tech_files, read_sector_data, sector = "Technology"))
health_data <- bind_rows(lapply(health_files, read_sector_data, sector = "Healthcare"))

# Combine all sector data into one dataset
combined_data <- bind_rows(banking_data, tech_data, health_data)

# Rename 'Source' to 'Stock' before further processing
combined_data <- combined_data |>
  rename(Stock = Source)

# Create the faceted line chart with sectors arranged in rows
p <- ggplot(combined_data, aes(x = date, y = close, color = Stock)) +
  geom_line(size = 1) +
  facet_grid(Sector ~ ., scales = "free_y") +  # Arrange facets in rows
  labs(
    title = "Stock Closing Prices Faceted by Sector",
    x = "Date",
    y = "Closing Price (USD)",
    color = "Stock"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )

# Display the plot
print(p)

```

## Opening Price

```{r fig.height=12, fig.width=15}
p <- ggplot(combined_data, aes(x = date, y = open, color = Stock)) +
  geom_line(size = 1) +
  facet_grid(Sector ~ ., scales = "free_y") +  # Arrange facets in rows
  labs(
    title = "Stock Opening Prices Faceted by Sector",
    x = "Date",
    y = "Closing Price (USD)",
    color = "Stock"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )

# Display the plot
print(p)

```

## Trade Volume

```{r fig.height=12, fig.width=15}
p <- ggplot(combined_data, aes(x = date, y = volume, color = Stock)) +
  geom_line(size = 1) +
  facet_grid(Sector ~ ., scales = "free_y") +  # Facet rows by Sector
  labs(
    title = "Stock Trading Volume Faceted by Sector",
    x = "Date",
    y = "Volume",
    color = "Stock"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, size = 16, face = "bold"),
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )

# Display the plot
print(p)

```

## 2. Stock Analysis By Events

### 2.1 Healthcare

```{r}
library(dplyr)
library(tidyr)
library(lubridate)
library(plotly)
library(zoo)

# Extract stock names from the Source column and pivot the data
wide_data <- health_data |> 
  mutate(Stock = sub(" Historical data", "", Source)) |> 
  select(date, close, Stock) |> 
  pivot_wider(names_from = Stock, values_from = close) |> 
  arrange(date)

# Fill missing values using linear interpolation
wide_data <- wide_data |> 
  mutate(across(-date, ~ na.approx(.x, na.rm = FALSE)))

# Define significant world events and their dates
events <- data.frame(
  date = as.Date(c("2019-04-15", "2020-03-11", "2020-12-14", "2021-01-06", 
                   "2022-02-24", "2023-10-07", "2024-11-05")),
  event = c("Notre-Dame Fire", "COVID-19 Declared", "Vaccine Rollout Begins", 
            "Capitol Riot", "Russia Invades Ukraine", "Israel-Hamas Conflict", 
            "2024 Presidential Election"),
  stringsAsFactors = FALSE
)

# Function to analyze stock performance around event dates
analyze_event_impact <- function(stock_data, event_date) {
  event_date <- as.Date(event_date)
  pre_event_date <- event_date - days(3)
  post_event_date <- event_date + days(3)
  
  relevant_prices <- stock_data |> 
    filter(date >= pre_event_date & date <= post_event_date)
  
  stock_columns <- setdiff(names(relevant_prices), "date")
  
  returns <- relevant_prices |> 
    mutate(across(all_of(stock_columns), ~ (.x / lag(.x) - 1) * 100, .names = "{.col}_return")) |>
    # Add event date for reference
    mutate(event_date = event_date)
  
  return(returns)
}

# Apply the function to each event and combine the results
impact_results <- events |> 
  rowwise() |> 
  do(analyze_event_impact(wide_data, .$date)) |> 
  ungroup()

# Combine results into a single data frame for reporting
results_df <- bind_rows(impact_results)

# Remove rows with all NA values in return columns
results_df <- results_df |> 
  filter(if_any(ends_with("_return"), ~ !is.na(.)))

# Prepare data for plotting
plot_data <- results_df |> 
  pivot_longer(
    cols = ends_with("_return"), 
    names_to = "Stock", 
    values_to = "Return",
    names_pattern = "(.+)_return"
  ) |> 
  filter(!is.na(Return))

# Create interactive plot using plotly
plot <- plot_ly()

# Add a trace for each stock
stocks <- unique(plot_data$Stock) # Get unique stock names from plot_data
for (stock in stocks) {
  stock_data <- plot_data |> filter(Stock == stock)
  
  plot <- plot |> add_trace(
    type = 'scatter',
    mode = 'lines+markers',
    x = stock_data$date,
    y = stock_data$Return,
    name = stock,
    legendgroup = stock,
    visible = 'legendonly' # Start with traces hidden
  )
}

print(stocks)

# Add vertical lines for events
for (i in seq_along(events$date)) {
  plot <- plot |> add_segments(
    x = events$date[i], xend = events$date[i],
    y = min(plot_data$Return, na.rm = TRUE), yend = max(plot_data$Return, na.rm = TRUE),
    line = list(color = 'red', dash='dash'),
    showlegend = FALSE
  )
}

# Customize layout
plot <- plot |> layout(
  title = "Stock Price Changes Around Major Events",
  xaxis = list(title = "Date"),
  yaxis = list(title = "Percentage Change (%)"),
  hovermode = "x unified"
)

# Display the plot
plot
```

### 2.2 Finance

```{r}
wide_data <- banking_data |> 
  mutate(Stock = sub(" Historical data", "", Source)) |> 
  select(date, close, Stock) |> 
  pivot_wider(names_from = Stock, values_from = close) |> 
  arrange(date)

# Fill missing values using linear interpolation
wide_data <- wide_data |> 
  mutate(across(-date, ~ na.approx(.x, na.rm = FALSE)))

# Apply the function to each event and combine the results
impact_results <- events |> 
  rowwise() |> 
  do(analyze_event_impact(wide_data, .$date)) |> 
  ungroup()

# Combine results into a single data frame for reporting
results_df <- bind_rows(impact_results)

# Remove rows with all NA values in return columns
results_df <- results_df |> 
  filter(if_any(ends_with("_return"), ~ !is.na(.)))

# Prepare data for plotting
plot_data <- results_df |> 
  pivot_longer(
    cols = ends_with("_return"), 
    names_to = "Stock", 
    values_to = "Return",
    names_pattern = "(.+)_return"
  ) |> 
  filter(!is.na(Return))

# Create interactive plot using plotly
plot <- plot_ly()

# Add a trace for each stock
stocks <- unique(plot_data$Stock) # Get unique stock names from plot_data
for (stock in stocks) {
  stock_data <- plot_data |> filter(Stock == stock)
  
  plot <- plot |> add_trace(
    type = 'scatter',
    mode = 'lines+markers',
    x = stock_data$date,
    y = stock_data$Return,
    name = stock,
    legendgroup = stock,
    visible = 'legendonly' # Start with traces hidden
  )
}

# Add vertical lines for events
for (i in seq_along(events$date)) {
  plot <- plot |> add_segments(
    x = events$date[i], xend = events$date[i],
    y = min(plot_data$Return, na.rm = TRUE), yend = max(plot_data$Return, na.rm = TRUE),
    line = list(color = 'red', dash='dash'),
    showlegend = FALSE
  )
}

# Customize layout
plot <- plot |> layout(
  title = "Stock Price Changes Around Major Events",
  xaxis = list(title = "Date"),
  yaxis = list(title = "Percentage Change (%)"),
  hovermode = "x unified"
)

# Display the plot
plot
```

### 2.3 Technology

```{r}

# Extract stock names from the Source column and pivot the data
wide_data <- tech_data |> 
  mutate(Stock = sub(" Historical data", "", Source)) |> 
  select(date, close, Stock) |> 
  pivot_wider(names_from = Stock, values_from = close) |> 
  arrange(date)

# Fill missing values using linear interpolation
wide_data <- wide_data |> 
  mutate(across(-date, ~ na.approx(.x, na.rm = FALSE)))

# Apply the function to each event and combine the results
impact_results <- events |> 
  rowwise() |> 
  do(analyze_event_impact(wide_data, .$date)) |> 
  ungroup()

# Combine results into a single data frame for reporting
results_df <- bind_rows(impact_results)

# Remove rows with all NA values in return columns
results_df <- results_df |> 
  filter(if_any(ends_with("_return"), ~ !is.na(.)))

# Prepare data for plotting
plot_data <- results_df |> 
  pivot_longer(
    cols = ends_with("_return"), 
    names_to = "Stock", 
    values_to = "Return",
    names_pattern = "(.+)_return"
  ) |> 
  filter(!is.na(Return))

# Create interactive plot using plotly
plot <- plot_ly()

# Add a trace for each stock
stocks <- unique(plot_data$Stock) # Get unique stock names from plot_data
for (stock in stocks) {
  stock_data <- plot_data |> filter(Stock == stock)
  
  plot <- plot |> add_trace(
    type = 'scatter',
    mode = 'lines+markers',
    x = stock_data$date,
    y = stock_data$Return,
    name = stock,
    legendgroup = stock,
    visible = 'legendonly' # Start with traces hidden
  )
}

# Add vertical lines for events
for (i in seq_along(events$date)) {
  plot <- plot |> add_segments(
    x = events$date[i], xend = events$date[i],
    y = min(plot_data$Return, na.rm = TRUE), yend = max(plot_data$Return, na.rm = TRUE),
    line = list(color = 'red', dash='dash'),
    showlegend = FALSE
  )
}

# Customize layout
plot <- plot |> layout(
  title = "Stock Price Changes Around Major Events",
  xaxis = list(title = "Date"),
  yaxis = list(title = "Percentage Change (%)"),
  hovermode = "x unified"
)

# Display the plot
plot
```

### 3 Volatility Analysis

### 3.1 Healthcare

```{r}
# Install and load required packages
# Install and load required packages
#install.packages("slider")
library(slider)
library(ggplot2)
library(dplyr)

# Calculate daily returns
health_data <- health_data |>
  group_by(Source) |>
  arrange(date) |>
  mutate(daily_return = (close / lag(close) - 1) * 100) |>
  ungroup()

# Calculate volatility (20-day rolling standard deviation of returns)
health_data <- health_data |>
  group_by(Source) |>
  mutate(volatility = slide_dbl(daily_return, sd, .before = 19, .complete = TRUE)) |>
  ungroup()

# Calculate average returns
avg_returns <- health_data |>
  group_by(Source) |>
  summarize(avg_daily_return = mean(daily_return, na.rm = TRUE)) |>
  arrange(desc(avg_daily_return))

print(avg_returns)

health_data_clean <- health_data |> filter(!is.na(daily_return))

# Plot daily returns
ggplot(health_data_clean, aes(x = date, y = daily_return, color = Source)) +
  geom_line() +
  labs(title = "Daily Returns by Stock", x = "Date", y = "Daily Return (%)") +
  theme_minimal()

```

```{r}
# Plot volatility
health_data_clean <- health_data |> filter(!is.na(volatility))
ggplot(health_data_clean, aes(x = date, y = volatility, color = Source)) +
  geom_line() +
  labs(title = "Volatility (20-Day Rolling Standard Deviation) by Stock", x = "Date", y = "Volatility (%)") +
  theme_minimal()
```

```{r}
library(TTR)

health_data <- health_data |>
  group_by(Source) |>
  mutate(RSI = TTR::RSI(close, n = 14)) |>
  ungroup()

health_data <- health_data |> filter(!is.na(RSI))

create_rsi_plot <- function(data, stock_name) {
  stock_data <- data |> filter(Source == stock_name)
  
  ggplot(stock_data, aes(x = date)) +
    geom_rect(aes(xmin = min(date), xmax = max(date), ymin = 70, ymax = 100), 
              fill = "pink", alpha = 0.2) +
    geom_rect(aes(xmin = min(date), xmax = max(date), ymin = 0, ymax = 30), 
              fill = "lightgreen", alpha = 0.2) +
    geom_line(aes(y = RSI), color = "black", linewidth = 0.8) +
    geom_hline(yintercept = 70, color = "red", linetype = "dashed", linewidth = 0.8) +
    geom_hline(yintercept = 30, color = "green", linetype = "dashed", linewidth = 0.8) +
    geom_hline(yintercept = 50, color = "gray", linetype = "dotted") +
    labs(title = paste("RSI Over Time -", stock_name), 
         subtitle = "With Overbought (>70) and Oversold (<30) Zones",
         x = "Date", 
         y = "RSI") +
    scale_y_continuous(limits = c(0, 100)) +
    theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      plot.title = element_text(face = "bold"),
      plot.subtitle = element_text(size = 9)
    )
}

# Create plots for each stock
stock_names <- unique(health_data$Source)
for(stock in stock_names) {
  print(create_rsi_plot(health_data, stock))
}


```

```{r fig.height=20 fig.width=15}
library(gridExtra)
library(grid)
performance_metrics <- health_data |>
  group_by(Source) |>
  summarize(
    sharpe_ratio = mean(daily_return, na.rm = TRUE) / 
                  sd(daily_return, na.rm = TRUE) * sqrt(252),
    max_drawdown = min(cumsum(daily_return), na.rm = TRUE),
    avg_volatility = mean(volatility, na.rm = TRUE)
  ) |>
  arrange(desc(sharpe_ratio))

print(performance_metrics)

# Calculate rolling metrics
health_data <- health_data |>
  group_by(Source) |>
  arrange(date) |>
  mutate(
    # Rolling Sharpe Ratio (252-day window)
    rolling_returns_mean = zoo::rollmean(daily_return, k = 252, fill = NA),
    rolling_returns_sd = zoo::rollapply(daily_return, width = 252, FUN = sd, fill = NA),
    rolling_sharpe = (rolling_returns_mean / rolling_returns_sd) * sqrt(252),
    
    # Rolling Maximum Drawdown
    cumulative_return = cumprod(1 + daily_return),
    rolling_max = zoo::rollmax(cumulative_return, k = 252, fill = NA),
    rolling_drawdown = (cumulative_return - rolling_max) / rolling_max
  ) |>
  ungroup()

health_data <- health_data |> filter(!is.na(rolling_sharpe))
health_data <- health_data |> filter(!is.na(rolling_drawdown))


# Create rolling Sharpe ratio plot
sharpe_plot <- ggplot(health_data, aes(x = date, y = rolling_sharpe, color = Source)) +
  geom_line() +
  labs(title = "Rolling Sharpe Ratio Over Time (252-day window)",
       x = "Date", y = "Sharpe Ratio") +
  theme_minimal() +
  theme(legend.position = "bottom")
# Arrange plots vertically
ggplot(health_data, aes(x = date, y = rolling_sharpe, color = Source)) +
  geom_line() +
  labs(title = "Rolling Sharpe Ratio Over Time",
       x = "Date", y = "Sharpe Ratio") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold")
  )


```

```{r fig.height=12 fig.width=20}
# Create rolling maximum drawdown plot
drawdown_plot <- ggplot(health_data, aes(x = date, y = rolling_drawdown, color = Source)) +
  geom_line() +
  labs(title = "Rolling Maximum Drawdown Over Time (252-day window)",
       x = "Date", y = "Drawdown") +
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot(health_data, aes(x = date, y = rolling_drawdown)) +
  geom_line() +
  labs(title = "Rolling Maximum Drawdown Over Time",
       x = "Date", y = "Drawdown") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold")
  ) +
  facet_wrap(~ Source)
```

### 3.2 Finance

```{r}
# Install and load required packages
# Install and load required packages
#install.packages("slider")
library(slider)
library(ggplot2)
library(dplyr)

# Calculate daily returns
banking_data <- banking_data |>
  group_by(Source) |>
  arrange(date) |>
  mutate(daily_return = (close / lag(close) - 1) * 100) |>
  ungroup()

# Calculate volatility (20-day rolling standard deviation of returns)
banking_data <- banking_data |>
  group_by(Source) |>
  mutate(volatility = slide_dbl(daily_return, sd, .before = 19, .complete = TRUE)) |>
  ungroup()

# Calculate average returns
avg_returns <- banking_data |>
  group_by(Source) |>
  summarize(avg_daily_return = mean(daily_return, na.rm = TRUE)) |>
  arrange(desc(avg_daily_return))

print(avg_returns)

banking_data_clean <- banking_data |> filter(!is.na(daily_return))

# Plot daily returns
ggplot(banking_data_clean, aes(x = date, y = daily_return, color = Source)) +
  geom_line() +
  labs(title = "Daily Returns by Stock", x = "Date", y = "Daily Return (%)") +
  theme_minimal()

```

```{r}
# Plot volatility
banking_data_clean <- banking_data |> filter(!is.na(volatility))
ggplot(banking_data_clean, aes(x = date, y = volatility, color = Source)) +
  geom_line() +
  labs(title = "Volatility (20-Day Rolling Standard Deviation) by Stock", x = "Date", y = "Volatility (%)") +
  theme_minimal()
```

```{r}
library(TTR)

banking_data <- banking_data |>
  group_by(Source) |>
  mutate(RSI = TTR::RSI(close, n = 14)) |>
  ungroup()

banking_data <- banking_data |> filter(!is.na(RSI))

create_rsi_plot <- function(data, stock_name) {
  stock_data <- data |> filter(Source == stock_name)
  
  ggplot(stock_data, aes(x = date)) +
    geom_rect(aes(xmin = min(date), xmax = max(date), ymin = 70, ymax = 100), 
              fill = "pink", alpha = 0.2) +
    geom_rect(aes(xmin = min(date), xmax = max(date), ymin = 0, ymax = 30), 
              fill = "lightgreen", alpha = 0.2) +
    geom_line(aes(y = RSI), color = "black", linewidth = 0.8) +
    geom_hline(yintercept = 70, color = "red", linetype = "dashed", linewidth = 0.8) +
    geom_hline(yintercept = 30, color = "green", linetype = "dashed", linewidth = 0.8) +
    geom_hline(yintercept = 50, color = "gray", linetype = "dotted") +
    labs(title = paste("RSI Over Time -", stock_name), 
         subtitle = "With Overbought (>70) and Oversold (<30) Zones",
         x = "Date", 
         y = "RSI") +
    scale_y_continuous(limits = c(0, 100)) +
    theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      plot.title = element_text(face = "bold"),
      plot.subtitle = element_text(size = 9)
    )
}

# Create plots for each stock
stock_names <- unique(banking_data$Source)
for(stock in stock_names) {
  print(create_rsi_plot(banking_data, stock))
}

```

```{r fig.height=20 fig.width=15}
library(gridExtra)
library(grid)
performance_metrics <- banking_data |>
  group_by(Source) |>
  summarize(
    sharpe_ratio = mean(daily_return, na.rm = TRUE) / 
                  sd(daily_return, na.rm = TRUE) * sqrt(252),
    max_drawdown = min(cumsum(daily_return), na.rm = TRUE),
    avg_volatility = mean(volatility, na.rm = TRUE)
  ) |>
  arrange(desc(sharpe_ratio))

print(performance_metrics)

# Calculate rolling metrics
banking_data <- banking_data |>
  group_by(Source) |>
  arrange(date) |>
  mutate(
    # Rolling Sharpe Ratio (252-day window)
    rolling_returns_mean = zoo::rollmean(daily_return, k = 252, fill = NA),
    rolling_returns_sd = zoo::rollapply(daily_return, width = 252, FUN = sd, fill = NA),
    rolling_sharpe = (rolling_returns_mean / rolling_returns_sd) * sqrt(252),
    
    # Rolling Maximum Drawdown
    cumulative_return = cumprod(1 + daily_return),
    rolling_max = zoo::rollmax(cumulative_return, k = 252, fill = NA),
    rolling_drawdown = (cumulative_return - rolling_max) / rolling_max
  ) |>
  ungroup()

banking_data <- banking_data |> filter(!is.na(rolling_sharpe))
banking_data <- banking_data |> filter(!is.na(rolling_drawdown))


# Create rolling Sharpe ratio plot
sharpe_plot <- ggplot(banking_data, aes(x = date, y = rolling_sharpe, color = Source)) +
  geom_line() +
  labs(title = "Rolling Sharpe Ratio Over Time (252-day window)",
       x = "Date", y = "Sharpe Ratio") +
  theme_minimal() +
  theme(legend.position = "bottom")
# Arrange plots vertically
ggplot(banking_data, aes(x = date, y = rolling_sharpe, color = Source)) +
  geom_line() +
  labs(title = "Rolling Sharpe Ratio Over Time",
       x = "Date", y = "Sharpe Ratio") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold")
  )


```

```{r fig.height=12 fig.width=20}
# Create rolling maximum drawdown plot
drawdown_plot <- ggplot(banking_data, aes(x = date, y = rolling_drawdown, color = Source)) +
  geom_line() +
  labs(title = "Rolling Maximum Drawdown Over Time (252-day window)",
       x = "Date", y = "Drawdown") +
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot(banking_data, aes(x = date, y = rolling_drawdown)) +
  geom_line() +
  labs(title = "Rolling Maximum Drawdown Over Time",
       x = "Date", y = "Drawdown") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold")
  ) +
  facet_wrap(~ Source)
```

### 3.3 Technology

```{r}
library(slider)
library(ggplot2)
library(dplyr)

# Calculate daily returns
tech_data <- tech_data %>%
  group_by(Source) %>%
  arrange(date) %>%
  mutate(daily_returns = (close / lag(close) - 1) * 100) %>%
  ungroup()

# Calculate volatility (20-day rolling standard deviation of returns)
tech_data <- tech_data %>%
  group_by(Source) %>%
  mutate(volatility = slide_dbl(daily_returns, sd, .before = 19, .complete = TRUE)) %>%
  ungroup()

# Calculate average returns
avg_returns <- tech_data %>%
  group_by(Source) %>%
  summarize(avg_daily_return = mean(daily_returns, na.rm = TRUE)) %>%
  arrange(desc(avg_daily_return))

print(avg_returns)

tech_data_clean <- tech_data %>% filter(!is.na(daily_returns))

# Plot daily returns
ggplot(tech_data_clean, aes(x = date, y = daily_returns, color = Source)) +
  geom_line() +
  labs(title = "Daily Returns by Stock", x = "Date", y = "Daily Return (%)") +
  theme_minimal()
```

```{r}
# Plot volatility
tech_data_clean <- tech_data %>% filter(!is.na(volatility))
ggplot(tech_data_clean, aes(x = date, y = volatility, color = Source)) +
  geom_line() +
  labs(title = "Volatility (20-Day Rolling Standard Deviation) by Stock", x = "Date", y = "Volatility (%)") +
  theme_minimal()
```

```{r}
library(TTR)

tech_data <- tech_data |>
  group_by(Source) |>
  mutate(RSI = TTR::RSI(close, n = 14)) |>
  ungroup()

tech_data <- tech_data %>% filter(!is.na(RSI))

create_rsi_plot <- function(data, stock_name) {
  stock_data <- data %>% filter(Source == stock_name)
  
  ggplot(stock_data, aes(x = date)) +
    geom_rect(aes(xmin = min(date), xmax = max(date), ymin = 70, ymax = 100), 
              fill = "pink", alpha = 0.2) +
    geom_rect(aes(xmin = min(date), xmax = max(date), ymin = 0, ymax = 30), 
              fill = "lightgreen", alpha = 0.2) +
    geom_line(aes(y = RSI), color = "black", linewidth = 0.8) +
    geom_hline(yintercept = 70, color = "red", linetype = "dashed", linewidth = 0.8) +
    geom_hline(yintercept = 30, color = "green", linetype = "dashed", linewidth = 0.8) +
    geom_hline(yintercept = 50, color = "gray", linetype = "dotted") +
    labs(title = paste("RSI Over Time -", stock_name), 
         subtitle = "With Overbought (>70) and Oversold (<30) Zones",
         x = "Date", 
         y = "RSI") +
    scale_y_continuous(limits = c(0, 100)) +
    theme_minimal() +
    theme(
      panel.grid.minor = element_blank(),
      axis.text.x = element_text(angle = 45, hjust = 1),
      plot.title = element_text(face = "bold"),
      plot.subtitle = element_text(size = 9)
    )
}

# Create plots for each stock
stock_names <- unique(tech_data$Source)
for(stock in stock_names) {
  print(create_rsi_plot(tech_data, stock))
}


```

```{r fig.height=20 fig.width=15}
library(gridExtra)
library(grid)
performance_metrics <- tech_data %>%
  group_by(Source) %>%
  summarize(
    sharpe_ratio = mean(daily_returns, na.rm = TRUE) / 
                  sd(daily_returns, na.rm = TRUE) * sqrt(252),
    max_drawdown = min(cumsum(daily_returns), na.rm = TRUE),
    avg_volatility = mean(volatility, na.rm = TRUE)
  ) %>%
  arrange(desc(sharpe_ratio))

print(performance_metrics)

# Calculate rolling metrics
tech_data <- tech_data %>%
  group_by(Source) %>%
  arrange(date) %>%
  mutate(
    # Rolling Sharpe Ratio (252-day window)
    rolling_returns_mean = zoo::rollmean(daily_returns, k = 252, fill = NA),
    rolling_returns_sd = zoo::rollapply(daily_returns, width = 252, FUN = sd, fill = NA),
    rolling_sharpe = (rolling_returns_mean / rolling_returns_sd) * sqrt(252),
    
    # Rolling Maximum Drawdown
    cumulative_return = cumprod(1 + daily_returns),
    rolling_max = zoo::rollmax(cumulative_return, k = 252, fill = NA),
    rolling_drawdown = (cumulative_return - rolling_max) / rolling_max
  ) %>%
  ungroup()

tech_data <- tech_data %>% filter(!is.na(rolling_sharpe))
tech_data <- tech_data %>% filter(!is.na(rolling_drawdown))


# Create rolling Sharpe ratio plot
sharpe_plot <- ggplot(tech_data, aes(x = date, y = rolling_sharpe, color = Source)) +
  geom_line() +
  labs(title = "Rolling Sharpe Ratio Over Time (252-day window)",
       x = "Date", y = "Sharpe Ratio") +
  theme_minimal() +
  theme(legend.position = "bottom")
# Arrange plots vertically
ggplot(tech_data, aes(x = date, y = rolling_sharpe, color = Source)) +
  geom_line() +
  labs(title = "Rolling Sharpe Ratio Over Time",
       x = "Date", y = "Sharpe Ratio") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold")
  )


```

```{r fig.height=12 fig.width=20}
# Create rolling maximum drawdown plot
drawdown_plot <- ggplot(tech_data, aes(x = date, y = rolling_drawdown, color = Source)) +
  geom_line() +
  labs(title = "Rolling Maximum Drawdown Over Time (252-day window)",
       x = "Date", y = "Drawdown") +
  theme_minimal() +
  theme(legend.position = "bottom")

ggplot(tech_data, aes(x = date, y = rolling_drawdown)) +
  geom_line() +
  labs(title = "Rolling Maximum Drawdown Over Time",
       x = "Date", y = "Drawdown") +
  theme_minimal() +
  theme(
    panel.grid.minor = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1),
    plot.title = element_text(face = "bold")
  ) +
  facet_wrap(~ Source)
```

### 4 Seasonal Patterns and Cycles

#### 4.1. Healthcare

```{r}
library(purrr)
# Clean and prepare the data
stocks_data <- health_data %>%
  filter(!is.na(date) & !is.na(close)) %>%  # Remove rows with missing Date or Price
  mutate(Date = as.Date(date)) %>%          # Convert Date to Date format
  arrange(Sector, Source, date)

# Define a function to perform seasonal decomposition and Fourier analysis
analyze_seasonal_patterns <- function(data, sector) {
  # Filter data for the given sector
  sector_data <- data %>% filter(Sector == sector)

  # Perform analysis for each stock
  sector_analysis <- sector_data %>%
    group_by(Source) %>%
    summarise(
      decomposed_plot = list({
        tryCatch({
          # Convert to time series object
          ts_data <- ts(
            close,
            frequency = 365,
            start = c(year(min(date)), yday(min(date)))
          )

          # Seasonal decomposition
          decomposed <- stl(ts_data, s.window = "periodic")

          # Plot decomposition
          autoplot(decomposed) + 
            ggtitle(paste("Seasonal Decomposition of", sector, "-", unique(Source)))
        }, error = function(e) {
          message(paste("Error processing decomposition for stock:", unique(Source)))
          NULL
        })
      }),
      fourier_plot = list({
        tryCatch({
          # Fourier transform
          ts_data <- ts(
            close,
            frequency = 365,
            start = c(year(min(date)), yday(min(date)))
          )
          spec <- spectrum(ts_data, spans = c(3, 3))

          # Return spectral density plot
          ggplot(data.frame(Frequency = spec$freq, SpectralDensity = spec$spec),
                 aes(x = Frequency, y = SpectralDensity)) +
            geom_line() +
            ggtitle(paste("Spectral Density of", sector, "-", unique(Source)))
        }, error = function(e) {
          message(paste("Error processing Fourier analysis for stock:", unique(Source)))
          NULL
        })
      })
    )

  # Return analysis
  return(sector_analysis)
}

# Perform analysis sector by sector
sectors <- unique(stocks_data$Sector)
results <- map(sectors, ~ analyze_seasonal_patterns(stocks_data, .x))

# Save or display plots
walk2(sectors, results, function(sector, sector_result) {
  message(paste("Processing sector:", sector))
  walk2(sector_result$decomposed_plot, sector_result$fourier_plot, function(decomp_plot, fourier_plot) {
    if (!is.null(decomp_plot)) print(decomp_plot)
    if (!is.null(fourier_plot)) print(fourier_plot)
  })
})


```

#### 4.2 Finance

```{r}


# Clean and prepare the data
stocks_data <- banking_data %>%
  filter(!is.na(date) & !is.na(close)) %>%  # Remove rows with missing Date or Price
  mutate(Date = as.Date(date)) %>%          # Convert Date to Date format
  arrange(Sector, Source, date)

# Perform analysis sector by sector
sectors <- unique(stocks_data$Sector)
results <- map(sectors, ~ analyze_seasonal_patterns(stocks_data, .x))

# Save or display plots
walk2(sectors, results, function(sector, sector_result) {
  message(paste("Processing sector:", sector))
  walk2(sector_result$decomposed_plot, sector_result$fourier_plot, function(decomp_plot, fourier_plot) {
    if (!is.null(decomp_plot)) print(decomp_plot)
    if (!is.null(fourier_plot)) print(fourier_plot)
  })
})


```

#### 4.3 Technology

```{r}

# Load necessary libraries
library(tidyverse)
library(lubridate)
library(forecast)
library(ggplot2)
library(tseries)

# Clean and prepare the data
stocks_data <- tech_data %>%
  filter(!is.na(date) & !is.na(close)) %>%  # Remove rows with missing Date or Price
  mutate(Date = as.Date(date)) %>%          # Convert Date to Date format
  arrange(Sector, Source, date)


# Perform analysis sector by sector
sectors <- unique(stocks_data$Sector)
results <- map(sectors, ~ analyze_seasonal_patterns(stocks_data, .x))

# Save or display plots
walk2(sectors, results, function(sector, sector_result) {
  message(paste("Processing sector:", sector))
  walk2(sector_result$decomposed_plot, sector_result$fourier_plot, function(decomp_plot, fourier_plot) {
    if (!is.null(decomp_plot)) print(decomp_plot)
    if (!is.null(fourier_plot)) print(fourier_plot)
  })
})


```
